# Today I Learned

## 날짜: 2024-05-23

### 스크럼

- 학습 목표 1 : Thread

### 새로 배운 내용

#### 주제 1: Thread와 Runnable

##### Thread
- 프로그램의 실행 프름을 나타내는 단위
- 하나의 프로세스 안에 여러 쓰레드를 가질 수 있고, 각 쓰레드는 독립적으로 실행 가능
- `Thread`는 `Runnable` 인터페이스의 구현체
- IO 작업이 많은 경우 / UI 응답성 향상을 위해 / 병렬 처리를 위해 사용한다

##### synchronized
- 쓰레드는 서로 독립적으로 실행되지만 동일한 메모리 공간을 공유(공유 자원)
- 공유 자원에 두 개 이상의 쓰레드가 동시에 접근해서 데이터를 읽고 변경하려할 때 발생하는 문제 상황(Race Condition)을 해결하기 위해 한 번에 하나의 쓰레드만 접근 가능하도록 제어하는 예약어

##### Race Condition(경쟁 상태)
- 두 개 이상의 쓰레드가 공유 자원에 접근해 동시에 변경하려고 할 때 발생하는 문제 상황
    - Race Condition 자체는 예외 상황이 아니다
    - "개발자 : Race Condition이 발생하는 걸 감지해서 예외 처리를 하겠다 !" 하면 예외 상황이 됨
    - 쓰레드가 공유 자원에 동시에 접근 하려고 하고, 쓰레드의 실행 순서가 보장되지 않기 때문에 발생
- 해결방안
    1. `synchronized (=mutex)`
        - 한 번에 하나의 쓰레드만 접근 가능하도록 제어하는 예약어
        - 메서드 혹은 블록으로 동기화 구현 가능
            - `synchronized (lock)` : 블록으로 구현하는 경우에 `lock` 사용
                - `synchronized 블록`에 접근하기 위해 획득해야하는 객체 = `lock`
                - `lock`을 획득한 객체만 블록에 접근할 수 있도록 하는 예약어
    2. `volatile`
        - 변수의 값을 모든 쓰레드에서 일관되게 보장하기 위해 사용하는 예약어
        - 쓰레드에 있는 변수의 값을 읽고 변경할 때, CPU 캐시를 거치지 않고 바로 메인 메모리에서 값을 가져오게 하는 예약어
        - 변수의 원자성을 보장하지는 않음!
        - Race Condition도 일부 해결 (완벽 해결 X)
    3. `semaphore`
        - semaphore 내부 정수 값(최대 semaphore 개수)에 따라 공유 자원 접근 가능한 쓰레드의 개수를 제한하는 예약어


##### Deadlock(데드락)
- 여러 쓰레드가 서로 소유하고 있는 자원을 기다리면서 무한 대기 상태에 빠지는 현상
- [ 조건 : 모두 충족해야 발생 ]
    1. 상호 배제 : 한 번에 하나의 쓰레드만 자원을 소유
    2. 소유하며 대기 : 최소 하나의 자원을 가진 채 다른 쓰레드가 소유하고 있는 자원을 추가 요구
    3. 비 선점 : 자원을 가지고 있는 쓰레드가 자원 사용을 완료하고 자발적으로 자원을 방출하기 전까지 다른 쓰레드나 프로세스가 강제 탈취할 수 없음
    4. 순환 대기 : `현재 스레드가 락 걸때 사용한 오브젝트를 다음 스레드가 필요로 한다는 말` : 이해를 못했다!


### 오늘의 도전 과제와 해결 방법

- 도전 과제 1: 6주차 과제 피드백 반영하기

### 오늘의 회고

- 어제 인터페이스를 6주차 과제에 적용해보려 했는데, 잘 안 됐다 ㅎ
- 와중에 과제 피드백을 받았기 때문에 인터페이스 외면하고 피드백을 먼저 보완하는 중
- 쓰레드 synchronized까지 오케이, 근데 경쟁 상태 해결법부터 머리가 안돌아갔다